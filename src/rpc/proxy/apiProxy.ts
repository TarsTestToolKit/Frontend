// **********************************************************************
// Parsed By TarsParser(2.4.13), Generated By tools(20200627)
// TarsParser Maintained By <TARS> and tools Maintained By <superzheng>
// Generated from "api.tars" by Client Mode
// **********************************************************************

/* tslint:disable */
/* eslint-disable */

/// <reference types="node" />
import assert = require("assert");
import * as TarsStream from "@tars/stream";
import * as TarsRpc from "@tars/rpc";

const _hasOwnProperty = Object.prototype.hasOwnProperty;
function _castFunctionInfo<Ret, Arg>(data: SharedFunctionInfo<Ret, Arg>) { return data; }
function _makeError(data: TarsRpc.RpcResponse, message: string, type?: number): TarsRpc.RpcError {
    var error: any = new Error(message || "");
    error.request = data.request;
    error.response = {
        costtime: data.request.costtime
    };
    if (type === TarsRpc.error.CLIENT.DECODE_ERROR) {
        error.name = "DECODE_ERROR";
        error.response.error = {
            code: type,
            message: message
        };
    } else {
        error.name = "RPC_ERROR";
        error.response.error = data.error;
    }
    return error;
}

export interface SharedFunctionInfo<Ret = any, Arg = any> extends TarsRpc.SharedFunctionInfo {
    tarsEncoder (...args: any[]): TarsStream.BinBuffer,
    tarsDecoder (data: TarsRpc.RpcResponse): TarsRpc.ProxyResponse<Ret, Arg>,
    tupEncoder (...args: any[]): TarsStream.UniAttribute,
    tupDecoder (data: TarsRpc.RpcResponse): TarsRpc.ProxyResponse<Ret, Arg>,
    errorResponser (data: TarsRpc.RpcResponse): never
}

export namespace apitars {
    export const RespCodeSucc: number = 0;
    export const FuncTest: string = "func";
    export const PerfTest: string = "perf";

    export class SimpleResp {
        code: number = 0;
        msg: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.SimpleResp";
        protected static _classname = "apitars.SimpleResp";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new SimpleResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): SimpleResp.Object { 
            return {
                code: this.code,
                msg: this.msg
            };
        }

        readFromObject(json: SimpleResp.Object) { 
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new SimpleResp();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.SimpleResp._readFrom(is);
        }
    }

    export namespace SimpleResp {
        export interface Object {
            code: number;
            msg: string;
        }
    }

    export class FuncTestDetail {
        from: string = "";
        to: string = "";
        isSucc: boolean = true;
        startTime: number = 0;
        endTime: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.FuncTestDetail";
        protected static _classname = "apitars.FuncTestDetail";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new FuncTestDetail;
            tmp.from = is.readString(0, true, "");
            tmp.to = is.readString(1, true, "");
            tmp.isSucc = is.readBoolean(2, true, true);
            tmp.startTime = is.readInt64(3, true, 0);
            tmp.endTime = is.readInt64(4, true, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.from);
            os.writeString(1, this.to);
            os.writeBoolean(2, this.isSucc);
            os.writeInt64(3, this.startTime);
            os.writeInt64(4, this.endTime);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): FuncTestDetail.Object { 
            return {
                from: this.from,
                to: this.to,
                isSucc: this.isSucc,
                startTime: this.startTime,
                endTime: this.endTime
            };
        }

        readFromObject(json: FuncTestDetail.Object) { 
            _hasOwnProperty.call(json, "from") && (this.from = json.from);
            _hasOwnProperty.call(json, "to") && (this.to = json.to);
            _hasOwnProperty.call(json, "isSucc") && (this.isSucc = json.isSucc);
            _hasOwnProperty.call(json, "startTime") && (this.startTime = json.startTime);
            _hasOwnProperty.call(json, "endTime") && (this.endTime = json.endTime);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new FuncTestDetail();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.FuncTestDetail._readFrom(is);
        }
    }

    export namespace FuncTestDetail {
        export interface Object {
            from: string;
            to: string;
            isSucc: boolean;
            startTime: number;
            endTime: number;
        }
    }

    export class FuncTestResp {
        code: number = 0;
        msg: string = "";
        rows: TarsStream.List<apitars.FuncTestDetail> = new TarsStream.List(apitars.FuncTestDetail);
        startTime: number = 0;
        endTime: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.FuncTestResp";
        protected static _classname = "apitars.FuncTestResp";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new FuncTestResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            tmp.rows = is.readList(2, false, TarsStream.List(apitars.FuncTestDetail));
            tmp.startTime = is.readInt64(3, true, 0);
            tmp.endTime = is.readInt64(4, true, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
            os.writeList(2, this.rows);
            os.writeInt64(3, this.startTime);
            os.writeInt64(4, this.endTime);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): FuncTestResp.Object { 
            return {
                code: this.code,
                msg: this.msg,
                rows: this.rows.toObject(),
                startTime: this.startTime,
                endTime: this.endTime
            };
        }

        readFromObject(json: FuncTestResp.Object) { 
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            _hasOwnProperty.call(json, "rows") && (this.rows.readFromObject(json.rows!));
            _hasOwnProperty.call(json, "startTime") && (this.startTime = json.startTime);
            _hasOwnProperty.call(json, "endTime") && (this.endTime = json.endTime);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new FuncTestResp();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.FuncTestResp._readFrom(is);
        }
    }

    export namespace FuncTestResp {
        export interface Object {
            code: number;
            msg: string;
            rows?: Array<apitars.FuncTestDetail.Object>;
            startTime: number;
            endTime: number;
        }
    }

    export class PerfTestReq {
        lang: string = "";
        servType: string = "";
        threads: number = 0;
        cores: number = 0;
        connCnt: number = 0;
        reqFreq: number = 0;
        keepAlive: number = 0;
        pkgLen: number = 0;
        memo: string = "";
        warmUp: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.PerfTestReq";
        protected static _classname = "apitars.PerfTestReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new PerfTestReq;
            tmp.lang = is.readString(0, true, "");
            tmp.servType = is.readString(1, true, "");
            tmp.threads = is.readUInt32(2, true, 0);
            tmp.cores = is.readUInt32(3, true, 0);
            tmp.connCnt = is.readUInt32(4, true, 0);
            tmp.reqFreq = is.readUInt32(5, true, 0);
            tmp.keepAlive = is.readUInt32(6, true, 0);
            tmp.pkgLen = is.readUInt32(7, true, 0);
            tmp.memo = is.readString(8, false, "");
            tmp.warmUp = is.readUInt32(9, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.lang);
            os.writeString(1, this.servType);
            os.writeUInt32(2, this.threads);
            os.writeUInt32(3, this.cores);
            os.writeUInt32(4, this.connCnt);
            os.writeUInt32(5, this.reqFreq);
            os.writeUInt32(6, this.keepAlive);
            os.writeUInt32(7, this.pkgLen);
            os.writeString(8, this.memo);
            os.writeUInt32(9, this.warmUp);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): PerfTestReq.Object { 
            return {
                lang: this.lang,
                servType: this.servType,
                threads: this.threads,
                cores: this.cores,
                connCnt: this.connCnt,
                reqFreq: this.reqFreq,
                keepAlive: this.keepAlive,
                pkgLen: this.pkgLen,
                memo: this.memo,
                warmUp: this.warmUp
            };
        }

        readFromObject(json: PerfTestReq.Object) { 
            _hasOwnProperty.call(json, "lang") && (this.lang = json.lang);
            _hasOwnProperty.call(json, "servType") && (this.servType = json.servType);
            _hasOwnProperty.call(json, "threads") && (this.threads = json.threads);
            _hasOwnProperty.call(json, "cores") && (this.cores = json.cores);
            _hasOwnProperty.call(json, "connCnt") && (this.connCnt = json.connCnt);
            _hasOwnProperty.call(json, "reqFreq") && (this.reqFreq = json.reqFreq);
            _hasOwnProperty.call(json, "keepAlive") && (this.keepAlive = json.keepAlive);
            _hasOwnProperty.call(json, "pkgLen") && (this.pkgLen = json.pkgLen);
            _hasOwnProperty.call(json, "memo") && (this.memo = json.memo!);
            _hasOwnProperty.call(json, "warmUp") && (this.warmUp = json.warmUp!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new PerfTestReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.PerfTestReq._readFrom(is);
        }
    }

    export namespace PerfTestReq {
        export interface Object {
            lang: string;
            servType: string;
            threads: number;
            cores: number;
            connCnt: number;
            reqFreq: number;
            keepAlive: number;
            pkgLen: number;
            memo?: string;
            warmUp?: number;
        }
    }

    export class PerfTestResp {
        code: number = 0;
        msg: string = "";
        testID: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.PerfTestResp";
        protected static _classname = "apitars.PerfTestResp";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new PerfTestResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            tmp.testID = is.readUInt32(2, true, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
            os.writeUInt32(2, this.testID);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): PerfTestResp.Object { 
            return {
                code: this.code,
                msg: this.msg,
                testID: this.testID
            };
        }

        readFromObject(json: PerfTestResp.Object) { 
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            _hasOwnProperty.call(json, "testID") && (this.testID = json.testID);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new PerfTestResp();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.PerfTestResp._readFrom(is);
        }
    }

    export namespace PerfTestResp {
        export interface Object {
            code: number;
            msg: string;
            testID: number;
        }
    }

    export class PerfTestDetail {
        timestamp: number = 0;
        qps: number = 0;
        totalReq: number = 0;
        succ: number = 0;
        failed: number = 0;
        succRate: string = "";
        costMax: number = 0;
        costMin: number = 0;
        costAvg: number = 0;
        p90: number = 0;
        p99: number = 0;
        p999: number = 0;
        sendByte: number = 0;
        recvByte: number = 0;
        costMap: TarsStream.Map<string, number> = new TarsStream.Map(TarsStream.String, TarsStream.Int64);
        retCodeMap: TarsStream.Map<string, number> = new TarsStream.Map(TarsStream.String, TarsStream.Int64);

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.PerfTestDetail";
        protected static _classname = "apitars.PerfTestDetail";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new PerfTestDetail;
            tmp.timestamp = is.readUInt32(0, true, 0);
            tmp.qps = is.readUInt32(1, true, 0);
            tmp.totalReq = is.readUInt32(2, true, 0);
            tmp.succ = is.readUInt32(3, true, 0);
            tmp.failed = is.readUInt32(4, true, 0);
            tmp.succRate = is.readString(5, true, "");
            tmp.costMax = is.readFloat(6, true, 0);
            tmp.costMin = is.readFloat(7, true, 0);
            tmp.costAvg = is.readFloat(8, true, 0);
            tmp.p90 = is.readFloat(9, true, 0);
            tmp.p99 = is.readFloat(10, true, 0);
            tmp.p999 = is.readFloat(11, true, 0);
            tmp.sendByte = is.readUInt32(12, true, 0);
            tmp.recvByte = is.readUInt32(13, true, 0);
            tmp.costMap = is.readMap(14, true, TarsStream.Map(TarsStream.String, TarsStream.Int64));
            tmp.retCodeMap = is.readMap(15, true, TarsStream.Map(TarsStream.String, TarsStream.Int64));
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.timestamp);
            os.writeUInt32(1, this.qps);
            os.writeUInt32(2, this.totalReq);
            os.writeUInt32(3, this.succ);
            os.writeUInt32(4, this.failed);
            os.writeString(5, this.succRate);
            os.writeFloat(6, this.costMax);
            os.writeFloat(7, this.costMin);
            os.writeFloat(8, this.costAvg);
            os.writeFloat(9, this.p90);
            os.writeFloat(10, this.p99);
            os.writeFloat(11, this.p999);
            os.writeUInt32(12, this.sendByte);
            os.writeUInt32(13, this.recvByte);
            os.writeMap(14, this.costMap);
            os.writeMap(15, this.retCodeMap);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): PerfTestDetail.Object { 
            return {
                timestamp: this.timestamp,
                qps: this.qps,
                totalReq: this.totalReq,
                succ: this.succ,
                failed: this.failed,
                succRate: this.succRate,
                costMax: this.costMax,
                costMin: this.costMin,
                costAvg: this.costAvg,
                p90: this.p90,
                p99: this.p99,
                p999: this.p999,
                sendByte: this.sendByte,
                recvByte: this.recvByte,
                costMap: this.costMap.toObject(),
                retCodeMap: this.retCodeMap.toObject()
            };
        }

        readFromObject(json: PerfTestDetail.Object) { 
            _hasOwnProperty.call(json, "timestamp") && (this.timestamp = json.timestamp);
            _hasOwnProperty.call(json, "qps") && (this.qps = json.qps);
            _hasOwnProperty.call(json, "totalReq") && (this.totalReq = json.totalReq);
            _hasOwnProperty.call(json, "succ") && (this.succ = json.succ);
            _hasOwnProperty.call(json, "failed") && (this.failed = json.failed);
            _hasOwnProperty.call(json, "succRate") && (this.succRate = json.succRate);
            _hasOwnProperty.call(json, "costMax") && (this.costMax = json.costMax);
            _hasOwnProperty.call(json, "costMin") && (this.costMin = json.costMin);
            _hasOwnProperty.call(json, "costAvg") && (this.costAvg = json.costAvg);
            _hasOwnProperty.call(json, "p90") && (this.p90 = json.p90);
            _hasOwnProperty.call(json, "p99") && (this.p99 = json.p99);
            _hasOwnProperty.call(json, "p999") && (this.p999 = json.p999);
            _hasOwnProperty.call(json, "sendByte") && (this.sendByte = json.sendByte);
            _hasOwnProperty.call(json, "recvByte") && (this.recvByte = json.recvByte);
            _hasOwnProperty.call(json, "costMap") && (this.costMap.readFromObject(json.costMap));
            _hasOwnProperty.call(json, "retCodeMap") && (this.retCodeMap.readFromObject(json.retCodeMap));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new PerfTestDetail();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.PerfTestDetail._readFrom(is);
        }
    }

    export namespace PerfTestDetail {
        export interface Object {
            timestamp: number;
            qps: number;
            totalReq: number;
            succ: number;
            failed: number;
            succRate: string;
            costMax: number;
            costMin: number;
            costAvg: number;
            p90: number;
            p99: number;
            p999: number;
            sendByte: number;
            recvByte: number;
            costMap: Record<string, number>;
            retCodeMap: Record<string, number>;
        }
    }

    export class CoreUsage {
        percent: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.CoreUsage";
        protected static _classname = "apitars.CoreUsage";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new CoreUsage;
            tmp.percent = is.readFloat(0, true, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeFloat(0, this.percent);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): CoreUsage.Object { 
            return {
                percent: this.percent
            };
        }

        readFromObject(json: CoreUsage.Object) { 
            _hasOwnProperty.call(json, "percent") && (this.percent = json.percent);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new CoreUsage();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.CoreUsage._readFrom(is);
        }
    }

    export namespace CoreUsage {
        export interface Object {
            percent: number;
        }
    }

    export class MemUsage {
        total: number = 0;
        used: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.MemUsage";
        protected static _classname = "apitars.MemUsage";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new MemUsage;
            tmp.total = is.readInt64(0, true, 0);
            tmp.used = is.readInt64(1, true, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt64(0, this.total);
            os.writeInt64(1, this.used);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): MemUsage.Object { 
            return {
                total: this.total,
                used: this.used
            };
        }

        readFromObject(json: MemUsage.Object) { 
            _hasOwnProperty.call(json, "total") && (this.total = json.total);
            _hasOwnProperty.call(json, "used") && (this.used = json.used);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new MemUsage();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.MemUsage._readFrom(is);
        }
    }

    export namespace MemUsage {
        export interface Object {
            total: number;
            used: number;
        }
    }

    export class PerfResDetail {
        timestamp: number = 0;
        cpu: TarsStream.List<apitars.CoreUsage> = new TarsStream.List(apitars.CoreUsage);
        mem: apitars.MemUsage = new apitars.MemUsage;

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.PerfResDetail";
        protected static _classname = "apitars.PerfResDetail";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new PerfResDetail;
            tmp.timestamp = is.readUInt32(0, true, 0);
            tmp.cpu = is.readList(1, true, TarsStream.List(apitars.CoreUsage));
            tmp.mem = is.readStruct(2, true, apitars.MemUsage);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.timestamp);
            os.writeList(1, this.cpu);
            os.writeStruct(2, this.mem);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): PerfResDetail.Object { 
            return {
                timestamp: this.timestamp,
                cpu: this.cpu.toObject(),
                mem: this.mem.toObject()
            };
        }

        readFromObject(json: PerfResDetail.Object) { 
            _hasOwnProperty.call(json, "timestamp") && (this.timestamp = json.timestamp);
            _hasOwnProperty.call(json, "cpu") && (this.cpu.readFromObject(json.cpu));
            _hasOwnProperty.call(json, "mem") && (this.mem.readFromObject(json.mem));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new PerfResDetail();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.PerfResDetail._readFrom(is);
        }
    }

    export namespace PerfResDetail {
        export interface Object {
            timestamp: number;
            cpu: Array<apitars.CoreUsage.Object>;
            mem: apitars.MemUsage.Object;
        }
    }

    export class TestDetailResp {
        code: number = 0;
        msg: string = "";
        perfDetail: TarsStream.List<apitars.PerfTestDetail> = new TarsStream.List(apitars.PerfTestDetail);
        resUsage: TarsStream.List<apitars.PerfResDetail> = new TarsStream.List(apitars.PerfResDetail);

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.TestDetailResp";
        protected static _classname = "apitars.TestDetailResp";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new TestDetailResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            tmp.perfDetail = is.readList(2, true, TarsStream.List(apitars.PerfTestDetail));
            tmp.resUsage = is.readList(3, true, TarsStream.List(apitars.PerfResDetail));
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
            os.writeList(2, this.perfDetail);
            os.writeList(3, this.resUsage);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): TestDetailResp.Object { 
            return {
                code: this.code,
                msg: this.msg,
                perfDetail: this.perfDetail.toObject(),
                resUsage: this.resUsage.toObject()
            };
        }

        readFromObject(json: TestDetailResp.Object) { 
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            _hasOwnProperty.call(json, "perfDetail") && (this.perfDetail.readFromObject(json.perfDetail));
            _hasOwnProperty.call(json, "resUsage") && (this.resUsage.readFromObject(json.resUsage));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new TestDetailResp();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.TestDetailResp._readFrom(is);
        }
    }

    export namespace TestDetailResp {
        export interface Object {
            code: number;
            msg: string;
            perfDetail: Array<apitars.PerfTestDetail.Object>;
            resUsage: Array<apitars.PerfResDetail.Object>;
        }
    }

    export class QueryTestHistoryReq {
        pageSize: number = 0;
        page: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.QueryTestHistoryReq";
        protected static _classname = "apitars.QueryTestHistoryReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new QueryTestHistoryReq;
            tmp.pageSize = is.readUInt32(0, false, 0);
            tmp.page = is.readUInt32(1, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.pageSize);
            os.writeUInt32(1, this.page);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): QueryTestHistoryReq.Object { 
            return {
                pageSize: this.pageSize,
                page: this.page
            };
        }

        readFromObject(json: QueryTestHistoryReq.Object) { 
            _hasOwnProperty.call(json, "pageSize") && (this.pageSize = json.pageSize!);
            _hasOwnProperty.call(json, "page") && (this.page = json.page!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new QueryTestHistoryReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.QueryTestHistoryReq._readFrom(is);
        }
    }

    export namespace QueryTestHistoryReq {
        export interface Object {
            pageSize?: number;
            page?: number;
        }
    }

    export class TestHistory {
        testID: number = 0;
        startTime: number = 0;
        endTime: number = 0;
        servType: string = "";
        lang: string = "";
        cores: number = 0;
        threads: number = 0;
        connCnt: number = 0;
        keepAlive: number = 0;
        reqFreq: number = 0;
        pkgLen: number = 0;
        finished: number = 0;
        memo: string = "";
        warmUp: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.TestHistory";
        protected static _classname = "apitars.TestHistory";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new TestHistory;
            tmp.testID = is.readUInt32(0, true, 0);
            tmp.startTime = is.readUInt32(1, true, 0);
            tmp.endTime = is.readUInt32(2, true, 0);
            tmp.servType = is.readString(3, true, "");
            tmp.lang = is.readString(4, true, "");
            tmp.cores = is.readUInt32(5, true, 0);
            tmp.threads = is.readUInt32(6, true, 0);
            tmp.connCnt = is.readUInt32(7, true, 0);
            tmp.keepAlive = is.readUInt32(8, true, 0);
            tmp.reqFreq = is.readUInt32(9, true, 0);
            tmp.pkgLen = is.readUInt32(10, true, 0);
            tmp.finished = is.readUInt32(11, true, 0);
            tmp.memo = is.readString(12, false, "");
            tmp.warmUp = is.readUInt32(13, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.testID);
            os.writeUInt32(1, this.startTime);
            os.writeUInt32(2, this.endTime);
            os.writeString(3, this.servType);
            os.writeString(4, this.lang);
            os.writeUInt32(5, this.cores);
            os.writeUInt32(6, this.threads);
            os.writeUInt32(7, this.connCnt);
            os.writeUInt32(8, this.keepAlive);
            os.writeUInt32(9, this.reqFreq);
            os.writeUInt32(10, this.pkgLen);
            os.writeUInt32(11, this.finished);
            os.writeString(12, this.memo);
            os.writeUInt32(13, this.warmUp);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): TestHistory.Object { 
            return {
                testID: this.testID,
                startTime: this.startTime,
                endTime: this.endTime,
                servType: this.servType,
                lang: this.lang,
                cores: this.cores,
                threads: this.threads,
                connCnt: this.connCnt,
                keepAlive: this.keepAlive,
                reqFreq: this.reqFreq,
                pkgLen: this.pkgLen,
                finished: this.finished,
                memo: this.memo,
                warmUp: this.warmUp
            };
        }

        readFromObject(json: TestHistory.Object) { 
            _hasOwnProperty.call(json, "testID") && (this.testID = json.testID);
            _hasOwnProperty.call(json, "startTime") && (this.startTime = json.startTime);
            _hasOwnProperty.call(json, "endTime") && (this.endTime = json.endTime);
            _hasOwnProperty.call(json, "servType") && (this.servType = json.servType);
            _hasOwnProperty.call(json, "lang") && (this.lang = json.lang);
            _hasOwnProperty.call(json, "cores") && (this.cores = json.cores);
            _hasOwnProperty.call(json, "threads") && (this.threads = json.threads);
            _hasOwnProperty.call(json, "connCnt") && (this.connCnt = json.connCnt);
            _hasOwnProperty.call(json, "keepAlive") && (this.keepAlive = json.keepAlive);
            _hasOwnProperty.call(json, "reqFreq") && (this.reqFreq = json.reqFreq);
            _hasOwnProperty.call(json, "pkgLen") && (this.pkgLen = json.pkgLen);
            _hasOwnProperty.call(json, "finished") && (this.finished = json.finished);
            _hasOwnProperty.call(json, "memo") && (this.memo = json.memo!);
            _hasOwnProperty.call(json, "warmUp") && (this.warmUp = json.warmUp!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new TestHistory();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.TestHistory._readFrom(is);
        }
    }

    export namespace TestHistory {
        export interface Object {
            testID: number;
            startTime: number;
            endTime: number;
            servType: string;
            lang: string;
            cores: number;
            threads: number;
            connCnt: number;
            keepAlive: number;
            reqFreq: number;
            pkgLen: number;
            finished: number;
            memo?: string;
            warmUp?: number;
        }
    }

    export class QueryTestHistoryResp {
        code: number = 0;
        msg: string = "";
        total: number = 0;
        page: number = 0;
        histories: TarsStream.List<apitars.TestHistory> = new TarsStream.List(apitars.TestHistory);

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.QueryTestHistoryResp";
        protected static _classname = "apitars.QueryTestHistoryResp";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new QueryTestHistoryResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            tmp.total = is.readUInt32(2, true, 0);
            tmp.page = is.readUInt32(3, true, 0);
            tmp.histories = is.readList(4, true, TarsStream.List(apitars.TestHistory));
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
            os.writeUInt32(2, this.total);
            os.writeUInt32(3, this.page);
            os.writeList(4, this.histories);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): QueryTestHistoryResp.Object { 
            return {
                code: this.code,
                msg: this.msg,
                total: this.total,
                page: this.page,
                histories: this.histories.toObject()
            };
        }

        readFromObject(json: QueryTestHistoryResp.Object) { 
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            _hasOwnProperty.call(json, "total") && (this.total = json.total);
            _hasOwnProperty.call(json, "page") && (this.page = json.page);
            _hasOwnProperty.call(json, "histories") && (this.histories.readFromObject(json.histories));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new QueryTestHistoryResp();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.QueryTestHistoryResp._readFrom(is);
        }
    }

    export namespace QueryTestHistoryResp {
        export interface Object {
            code: number;
            msg: string;
            total: number;
            page: number;
            histories: Array<apitars.TestHistory.Object>;
        }
    }

    export class IsPerfExistsReq {
        servType: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.IsPerfExistsReq";
        protected static _classname = "apitars.IsPerfExistsReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new IsPerfExistsReq;
            tmp.servType = is.readString(0, true, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.servType);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): IsPerfExistsReq.Object { 
            return {
                servType: this.servType
            };
        }

        readFromObject(json: IsPerfExistsReq.Object) { 
            _hasOwnProperty.call(json, "servType") && (this.servType = json.servType);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new IsPerfExistsReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.IsPerfExistsReq._readFrom(is);
        }
    }

    export namespace IsPerfExistsReq {
        export interface Object {
            servType: string;
        }
    }

    export class IsPerfExistsResp {
        code: number = 0;
        msg: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "apitars.IsPerfExistsResp";
        protected static _classname = "apitars.IsPerfExistsResp";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new IsPerfExistsResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): IsPerfExistsResp.Object { 
            return {
                code: this.code,
                msg: this.msg
            };
        }

        readFromObject(json: IsPerfExistsResp.Object) { 
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new IsPerfExistsResp();
        }

        static create(is: TarsStream.TarsInputStream) {
            return apitars.IsPerfExistsResp._readFrom(is);
        }
    }

    export namespace IsPerfExistsResp {
        export interface Object {
            code: number;
            msg: string;
        }
    }

    export class apiProxy {
        protected _name!: string
        protected _worker!: TarsRpc.ObjectProxy

        setTimeout (iTimeout: number) { this._worker.timeout = iTimeout; }
        getTimeout () { return this._worker.timeout; }
        setVersion (iVersion: number) { this._worker.version = iVersion; }
        getVersion () { return this._worker.version; }

        static doFuncTest = _castFunctionInfo({
            name: "doFuncTest",
            return: "apitars.FuncTestResp",
            arguments: [],
            tarsEncoder() {
                const os = new TarsStream.TarsOutputStream();
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readStruct(0, true, apitars.FuncTestResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(__$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readStruct("", apitars.FuncTestResp, new apitars.FuncTestResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call api::doFuncTest failed");
            }
        })

        doFuncTest(options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("doFuncTest", apiProxy.doFuncTest.tupEncoder(version), options, apiProxy.doFuncTest).then(apiProxy.doFuncTest.tupDecoder, apiProxy.doFuncTest.errorResponser);
            } else {
                return this._worker.tars_invoke("doFuncTest", apiProxy.doFuncTest.tarsEncoder(), options, apiProxy.doFuncTest).then(apiProxy.doFuncTest.tarsDecoder, apiProxy.doFuncTest.errorResponser);
            }
        }

        static doPerfTest = _castFunctionInfo({
            name: "doPerfTest",
            return: "apitars.PerfTestResp",
            arguments: [{
                name: "req",
                class: "apitars.PerfTestReq",
                direction: "in"
            }],
            tarsEncoder(req: apitars.PerfTestReq) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readStruct(0, true, apitars.PerfTestResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(req: apitars.PerfTestReq, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readStruct("", apitars.PerfTestResp, new apitars.PerfTestResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call api::doPerfTest failed");
            }
        })

        doPerfTest(req: apitars.PerfTestReq, options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("doPerfTest", apiProxy.doPerfTest.tupEncoder(req, version), options, apiProxy.doPerfTest).then(apiProxy.doPerfTest.tupDecoder, apiProxy.doPerfTest.errorResponser);
            } else {
                return this._worker.tars_invoke("doPerfTest", apiProxy.doPerfTest.tarsEncoder(req), options, apiProxy.doPerfTest).then(apiProxy.doPerfTest.tarsDecoder, apiProxy.doPerfTest.errorResponser);
            }
        }

        static getTestDetail = _castFunctionInfo({
            name: "getTestDetail",
            return: "apitars.TestDetailResp",
            arguments: [{
                name: "testID",
                class: "int64",
                direction: "in"
            }, {
                name: "timestamp",
                class: "int64",
                direction: "in"
            }, {
                name: "showWarmUp",
                class: "bool",
                direction: "in"
            }],
            tarsEncoder(testID: number, timestamp: number, showWarmUp: boolean) {
                const os = new TarsStream.TarsOutputStream();
                os.writeUInt32(1, testID);
                os.writeUInt32(2, timestamp);
                os.writeBoolean(3, showWarmUp);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readStruct(0, true, apitars.TestDetailResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(testID: number, timestamp: number, showWarmUp: boolean, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeUInt32("testID", testID);
                tup.writeUInt32("timestamp", timestamp);
                tup.writeBoolean("showWarmUp", showWarmUp);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readStruct("", apitars.TestDetailResp, new apitars.TestDetailResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call api::getTestDetail failed");
            }
        })

        getTestDetail(testID: number, timestamp: number, showWarmUp: boolean, options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("getTestDetail", apiProxy.getTestDetail.tupEncoder(testID, timestamp, showWarmUp, version), options, apiProxy.getTestDetail).then(apiProxy.getTestDetail.tupDecoder, apiProxy.getTestDetail.errorResponser);
            } else {
                return this._worker.tars_invoke("getTestDetail", apiProxy.getTestDetail.tarsEncoder(testID, timestamp, showWarmUp), options, apiProxy.getTestDetail).then(apiProxy.getTestDetail.tarsDecoder, apiProxy.getTestDetail.errorResponser);
            }
        }

        static getTestHistories = _castFunctionInfo({
            name: "getTestHistories",
            return: "apitars.QueryTestHistoryResp",
            arguments: [{
                name: "req",
                class: "apitars.QueryTestHistoryReq",
                direction: "in"
            }],
            tarsEncoder(req: apitars.QueryTestHistoryReq) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readStruct(0, true, apitars.QueryTestHistoryResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(req: apitars.QueryTestHistoryReq, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readStruct("", apitars.QueryTestHistoryResp, new apitars.QueryTestHistoryResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call api::getTestHistories failed");
            }
        })

        getTestHistories(req: apitars.QueryTestHistoryReq, options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("getTestHistories", apiProxy.getTestHistories.tupEncoder(req, version), options, apiProxy.getTestHistories).then(apiProxy.getTestHistories.tupDecoder, apiProxy.getTestHistories.errorResponser);
            } else {
                return this._worker.tars_invoke("getTestHistories", apiProxy.getTestHistories.tarsEncoder(req), options, apiProxy.getTestHistories).then(apiProxy.getTestHistories.tarsDecoder, apiProxy.getTestHistories.errorResponser);
            }
        }

        static isPerfExists = _castFunctionInfo({
            name: "isPerfExists",
            return: "apitars.IsPerfExistsResp",
            arguments: [{
                name: "req",
                class: "apitars.IsPerfExistsReq",
                direction: "in"
            }],
            tarsEncoder(req: apitars.IsPerfExistsReq) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readStruct(0, true, apitars.IsPerfExistsResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(req: apitars.IsPerfExistsReq, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readStruct("", apitars.IsPerfExistsResp, new apitars.IsPerfExistsResp),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call api::isPerfExists failed");
            }
        })

        isPerfExists(req: apitars.IsPerfExistsReq, options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("isPerfExists", apiProxy.isPerfExists.tupEncoder(req, version), options, apiProxy.isPerfExists).then(apiProxy.isPerfExists.tupDecoder, apiProxy.isPerfExists.errorResponser);
            } else {
                return this._worker.tars_invoke("isPerfExists", apiProxy.isPerfExists.tarsEncoder(req), options, apiProxy.isPerfExists).then(apiProxy.isPerfExists.tarsDecoder, apiProxy.isPerfExists.errorResponser);
            }
        }


    }

}


