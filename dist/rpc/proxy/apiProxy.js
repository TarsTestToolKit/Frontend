"use strict";
// **********************************************************************
// Parsed By TarsParser(2.4.13), Generated By tools(20200627)
// TarsParser Maintained By <TARS> and tools Maintained By <superzheng>
// Generated from "api.tars" by Client Mode
// **********************************************************************
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.apitars = void 0;
/* tslint:disable */
/* eslint-disable */
/// <reference types="node" />
const assert = require("assert");
const TarsStream = __importStar(require("@tars/stream"));
const TarsRpc = __importStar(require("@tars/rpc"));
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function _castFunctionInfo(data) { return data; }
function _makeError(data, message, type) {
    var error = new Error(message || "");
    error.request = data.request;
    error.response = {
        costtime: data.request.costtime
    };
    if (type === TarsRpc.error.CLIENT.DECODE_ERROR) {
        error.name = "DECODE_ERROR";
        error.response.error = {
            code: type,
            message: message
        };
    }
    else {
        error.name = "RPC_ERROR";
        error.response.error = data.error;
    }
    return error;
}
var apitars;
(function (apitars) {
    apitars.RespCodeSucc = 0;
    apitars.FuncTest = "func";
    apitars.PerfTest = "perf";
    class SimpleResp {
        constructor() {
            this.code = 0;
            this.msg = "";
            this._proto_struct_name_ = "";
            this._classname = "apitars.SimpleResp";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new SimpleResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                code: this.code,
                msg: this.msg
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new SimpleResp();
        }
        static create(is) {
            return apitars.SimpleResp._readFrom(is);
        }
    }
    SimpleResp._classname = "apitars.SimpleResp";
    apitars.SimpleResp = SimpleResp;
    class FuncTestDetail {
        constructor() {
            this.from = "";
            this.to = "";
            this.isSucc = true;
            this.startTime = 0;
            this.endTime = 0;
            this._proto_struct_name_ = "";
            this._classname = "apitars.FuncTestDetail";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new FuncTestDetail;
            tmp.from = is.readString(0, true, "");
            tmp.to = is.readString(1, true, "");
            tmp.isSucc = is.readBoolean(2, true, true);
            tmp.startTime = is.readInt64(3, true, 0);
            tmp.endTime = is.readInt64(4, true, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.from);
            os.writeString(1, this.to);
            os.writeBoolean(2, this.isSucc);
            os.writeInt64(3, this.startTime);
            os.writeInt64(4, this.endTime);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                from: this.from,
                to: this.to,
                isSucc: this.isSucc,
                startTime: this.startTime,
                endTime: this.endTime
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "from") && (this.from = json.from);
            _hasOwnProperty.call(json, "to") && (this.to = json.to);
            _hasOwnProperty.call(json, "isSucc") && (this.isSucc = json.isSucc);
            _hasOwnProperty.call(json, "startTime") && (this.startTime = json.startTime);
            _hasOwnProperty.call(json, "endTime") && (this.endTime = json.endTime);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new FuncTestDetail();
        }
        static create(is) {
            return apitars.FuncTestDetail._readFrom(is);
        }
    }
    FuncTestDetail._classname = "apitars.FuncTestDetail";
    apitars.FuncTestDetail = FuncTestDetail;
    class FuncTestResp {
        constructor() {
            this.code = 0;
            this.msg = "";
            this.rows = new TarsStream.List(apitars.FuncTestDetail);
            this.startTime = 0;
            this.endTime = 0;
            this._proto_struct_name_ = "";
            this._classname = "apitars.FuncTestResp";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new FuncTestResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            tmp.rows = is.readList(2, false, TarsStream.List(apitars.FuncTestDetail));
            tmp.startTime = is.readInt64(3, true, 0);
            tmp.endTime = is.readInt64(4, true, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
            os.writeList(2, this.rows);
            os.writeInt64(3, this.startTime);
            os.writeInt64(4, this.endTime);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                code: this.code,
                msg: this.msg,
                rows: this.rows.toObject(),
                startTime: this.startTime,
                endTime: this.endTime
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            _hasOwnProperty.call(json, "rows") && (this.rows.readFromObject(json.rows));
            _hasOwnProperty.call(json, "startTime") && (this.startTime = json.startTime);
            _hasOwnProperty.call(json, "endTime") && (this.endTime = json.endTime);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new FuncTestResp();
        }
        static create(is) {
            return apitars.FuncTestResp._readFrom(is);
        }
    }
    FuncTestResp._classname = "apitars.FuncTestResp";
    apitars.FuncTestResp = FuncTestResp;
    class PerfTestReq {
        constructor() {
            this.lang = "";
            this.servType = "";
            this.threads = 0;
            this.cores = 0;
            this.connCnt = 0;
            this.reqFreq = 0;
            this.keepAlive = 0;
            this.pkgLen = 0;
            this.memo = "";
            this.warmUp = 0;
            this._proto_struct_name_ = "";
            this._classname = "apitars.PerfTestReq";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new PerfTestReq;
            tmp.lang = is.readString(0, true, "");
            tmp.servType = is.readString(1, true, "");
            tmp.threads = is.readUInt32(2, true, 0);
            tmp.cores = is.readUInt32(3, true, 0);
            tmp.connCnt = is.readUInt32(4, true, 0);
            tmp.reqFreq = is.readUInt32(5, true, 0);
            tmp.keepAlive = is.readUInt32(6, true, 0);
            tmp.pkgLen = is.readUInt32(7, true, 0);
            tmp.memo = is.readString(8, false, "");
            tmp.warmUp = is.readUInt32(9, false, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.lang);
            os.writeString(1, this.servType);
            os.writeUInt32(2, this.threads);
            os.writeUInt32(3, this.cores);
            os.writeUInt32(4, this.connCnt);
            os.writeUInt32(5, this.reqFreq);
            os.writeUInt32(6, this.keepAlive);
            os.writeUInt32(7, this.pkgLen);
            os.writeString(8, this.memo);
            os.writeUInt32(9, this.warmUp);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                lang: this.lang,
                servType: this.servType,
                threads: this.threads,
                cores: this.cores,
                connCnt: this.connCnt,
                reqFreq: this.reqFreq,
                keepAlive: this.keepAlive,
                pkgLen: this.pkgLen,
                memo: this.memo,
                warmUp: this.warmUp
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "lang") && (this.lang = json.lang);
            _hasOwnProperty.call(json, "servType") && (this.servType = json.servType);
            _hasOwnProperty.call(json, "threads") && (this.threads = json.threads);
            _hasOwnProperty.call(json, "cores") && (this.cores = json.cores);
            _hasOwnProperty.call(json, "connCnt") && (this.connCnt = json.connCnt);
            _hasOwnProperty.call(json, "reqFreq") && (this.reqFreq = json.reqFreq);
            _hasOwnProperty.call(json, "keepAlive") && (this.keepAlive = json.keepAlive);
            _hasOwnProperty.call(json, "pkgLen") && (this.pkgLen = json.pkgLen);
            _hasOwnProperty.call(json, "memo") && (this.memo = json.memo);
            _hasOwnProperty.call(json, "warmUp") && (this.warmUp = json.warmUp);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new PerfTestReq();
        }
        static create(is) {
            return apitars.PerfTestReq._readFrom(is);
        }
    }
    PerfTestReq._classname = "apitars.PerfTestReq";
    apitars.PerfTestReq = PerfTestReq;
    class PerfTestResp {
        constructor() {
            this.code = 0;
            this.msg = "";
            this.testID = 0;
            this._proto_struct_name_ = "";
            this._classname = "apitars.PerfTestResp";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new PerfTestResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            tmp.testID = is.readUInt32(2, true, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
            os.writeUInt32(2, this.testID);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                code: this.code,
                msg: this.msg,
                testID: this.testID
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            _hasOwnProperty.call(json, "testID") && (this.testID = json.testID);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new PerfTestResp();
        }
        static create(is) {
            return apitars.PerfTestResp._readFrom(is);
        }
    }
    PerfTestResp._classname = "apitars.PerfTestResp";
    apitars.PerfTestResp = PerfTestResp;
    class PerfTestDetail {
        constructor() {
            this.timestamp = 0;
            this.qps = 0;
            this.totalReq = 0;
            this.succ = 0;
            this.failed = 0;
            this.succRate = "";
            this.costMax = 0;
            this.costMin = 0;
            this.costAvg = 0;
            this.p90 = 0;
            this.p99 = 0;
            this.p999 = 0;
            this.sendByte = 0;
            this.recvByte = 0;
            this.costMap = new TarsStream.Map(TarsStream.String, TarsStream.Int64);
            this.retCodeMap = new TarsStream.Map(TarsStream.String, TarsStream.Int64);
            this._proto_struct_name_ = "";
            this._classname = "apitars.PerfTestDetail";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new PerfTestDetail;
            tmp.timestamp = is.readUInt32(0, true, 0);
            tmp.qps = is.readUInt32(1, true, 0);
            tmp.totalReq = is.readUInt32(2, true, 0);
            tmp.succ = is.readUInt32(3, true, 0);
            tmp.failed = is.readUInt32(4, true, 0);
            tmp.succRate = is.readString(5, true, "");
            tmp.costMax = is.readFloat(6, true, 0);
            tmp.costMin = is.readFloat(7, true, 0);
            tmp.costAvg = is.readFloat(8, true, 0);
            tmp.p90 = is.readFloat(9, true, 0);
            tmp.p99 = is.readFloat(10, true, 0);
            tmp.p999 = is.readFloat(11, true, 0);
            tmp.sendByte = is.readUInt32(12, true, 0);
            tmp.recvByte = is.readUInt32(13, true, 0);
            tmp.costMap = is.readMap(14, true, TarsStream.Map(TarsStream.String, TarsStream.Int64));
            tmp.retCodeMap = is.readMap(15, true, TarsStream.Map(TarsStream.String, TarsStream.Int64));
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.timestamp);
            os.writeUInt32(1, this.qps);
            os.writeUInt32(2, this.totalReq);
            os.writeUInt32(3, this.succ);
            os.writeUInt32(4, this.failed);
            os.writeString(5, this.succRate);
            os.writeFloat(6, this.costMax);
            os.writeFloat(7, this.costMin);
            os.writeFloat(8, this.costAvg);
            os.writeFloat(9, this.p90);
            os.writeFloat(10, this.p99);
            os.writeFloat(11, this.p999);
            os.writeUInt32(12, this.sendByte);
            os.writeUInt32(13, this.recvByte);
            os.writeMap(14, this.costMap);
            os.writeMap(15, this.retCodeMap);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                timestamp: this.timestamp,
                qps: this.qps,
                totalReq: this.totalReq,
                succ: this.succ,
                failed: this.failed,
                succRate: this.succRate,
                costMax: this.costMax,
                costMin: this.costMin,
                costAvg: this.costAvg,
                p90: this.p90,
                p99: this.p99,
                p999: this.p999,
                sendByte: this.sendByte,
                recvByte: this.recvByte,
                costMap: this.costMap.toObject(),
                retCodeMap: this.retCodeMap.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "timestamp") && (this.timestamp = json.timestamp);
            _hasOwnProperty.call(json, "qps") && (this.qps = json.qps);
            _hasOwnProperty.call(json, "totalReq") && (this.totalReq = json.totalReq);
            _hasOwnProperty.call(json, "succ") && (this.succ = json.succ);
            _hasOwnProperty.call(json, "failed") && (this.failed = json.failed);
            _hasOwnProperty.call(json, "succRate") && (this.succRate = json.succRate);
            _hasOwnProperty.call(json, "costMax") && (this.costMax = json.costMax);
            _hasOwnProperty.call(json, "costMin") && (this.costMin = json.costMin);
            _hasOwnProperty.call(json, "costAvg") && (this.costAvg = json.costAvg);
            _hasOwnProperty.call(json, "p90") && (this.p90 = json.p90);
            _hasOwnProperty.call(json, "p99") && (this.p99 = json.p99);
            _hasOwnProperty.call(json, "p999") && (this.p999 = json.p999);
            _hasOwnProperty.call(json, "sendByte") && (this.sendByte = json.sendByte);
            _hasOwnProperty.call(json, "recvByte") && (this.recvByte = json.recvByte);
            _hasOwnProperty.call(json, "costMap") && (this.costMap.readFromObject(json.costMap));
            _hasOwnProperty.call(json, "retCodeMap") && (this.retCodeMap.readFromObject(json.retCodeMap));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new PerfTestDetail();
        }
        static create(is) {
            return apitars.PerfTestDetail._readFrom(is);
        }
    }
    PerfTestDetail._classname = "apitars.PerfTestDetail";
    apitars.PerfTestDetail = PerfTestDetail;
    class CoreUsage {
        constructor() {
            this.percent = 0;
            this._proto_struct_name_ = "";
            this._classname = "apitars.CoreUsage";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new CoreUsage;
            tmp.percent = is.readFloat(0, true, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeFloat(0, this.percent);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                percent: this.percent
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "percent") && (this.percent = json.percent);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new CoreUsage();
        }
        static create(is) {
            return apitars.CoreUsage._readFrom(is);
        }
    }
    CoreUsage._classname = "apitars.CoreUsage";
    apitars.CoreUsage = CoreUsage;
    class MemUsage {
        constructor() {
            this.total = 0;
            this.used = 0;
            this._proto_struct_name_ = "";
            this._classname = "apitars.MemUsage";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new MemUsage;
            tmp.total = is.readInt64(0, true, 0);
            tmp.used = is.readInt64(1, true, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeInt64(0, this.total);
            os.writeInt64(1, this.used);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                total: this.total,
                used: this.used
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "total") && (this.total = json.total);
            _hasOwnProperty.call(json, "used") && (this.used = json.used);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new MemUsage();
        }
        static create(is) {
            return apitars.MemUsage._readFrom(is);
        }
    }
    MemUsage._classname = "apitars.MemUsage";
    apitars.MemUsage = MemUsage;
    class PerfResDetail {
        constructor() {
            this.timestamp = 0;
            this.cpu = new TarsStream.List(apitars.CoreUsage);
            this.mem = new apitars.MemUsage;
            this._proto_struct_name_ = "";
            this._classname = "apitars.PerfResDetail";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new PerfResDetail;
            tmp.timestamp = is.readUInt32(0, true, 0);
            tmp.cpu = is.readList(1, true, TarsStream.List(apitars.CoreUsage));
            tmp.mem = is.readStruct(2, true, apitars.MemUsage);
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.timestamp);
            os.writeList(1, this.cpu);
            os.writeStruct(2, this.mem);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                timestamp: this.timestamp,
                cpu: this.cpu.toObject(),
                mem: this.mem.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "timestamp") && (this.timestamp = json.timestamp);
            _hasOwnProperty.call(json, "cpu") && (this.cpu.readFromObject(json.cpu));
            _hasOwnProperty.call(json, "mem") && (this.mem.readFromObject(json.mem));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new PerfResDetail();
        }
        static create(is) {
            return apitars.PerfResDetail._readFrom(is);
        }
    }
    PerfResDetail._classname = "apitars.PerfResDetail";
    apitars.PerfResDetail = PerfResDetail;
    class TestDetailResp {
        constructor() {
            this.code = 0;
            this.msg = "";
            this.perfDetail = new TarsStream.List(apitars.PerfTestDetail);
            this.resUsage = new TarsStream.List(apitars.PerfResDetail);
            this._proto_struct_name_ = "";
            this._classname = "apitars.TestDetailResp";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new TestDetailResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            tmp.perfDetail = is.readList(2, true, TarsStream.List(apitars.PerfTestDetail));
            tmp.resUsage = is.readList(3, true, TarsStream.List(apitars.PerfResDetail));
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
            os.writeList(2, this.perfDetail);
            os.writeList(3, this.resUsage);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                code: this.code,
                msg: this.msg,
                perfDetail: this.perfDetail.toObject(),
                resUsage: this.resUsage.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            _hasOwnProperty.call(json, "perfDetail") && (this.perfDetail.readFromObject(json.perfDetail));
            _hasOwnProperty.call(json, "resUsage") && (this.resUsage.readFromObject(json.resUsage));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new TestDetailResp();
        }
        static create(is) {
            return apitars.TestDetailResp._readFrom(is);
        }
    }
    TestDetailResp._classname = "apitars.TestDetailResp";
    apitars.TestDetailResp = TestDetailResp;
    class QueryTestHistoryReq {
        constructor() {
            this.pageSize = 0;
            this.page = 0;
            this._proto_struct_name_ = "";
            this._classname = "apitars.QueryTestHistoryReq";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new QueryTestHistoryReq;
            tmp.pageSize = is.readUInt32(0, false, 0);
            tmp.page = is.readUInt32(1, false, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.pageSize);
            os.writeUInt32(1, this.page);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                pageSize: this.pageSize,
                page: this.page
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "pageSize") && (this.pageSize = json.pageSize);
            _hasOwnProperty.call(json, "page") && (this.page = json.page);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new QueryTestHistoryReq();
        }
        static create(is) {
            return apitars.QueryTestHistoryReq._readFrom(is);
        }
    }
    QueryTestHistoryReq._classname = "apitars.QueryTestHistoryReq";
    apitars.QueryTestHistoryReq = QueryTestHistoryReq;
    class TestHistory {
        constructor() {
            this.testID = 0;
            this.startTime = 0;
            this.endTime = 0;
            this.servType = "";
            this.lang = "";
            this.cores = 0;
            this.threads = 0;
            this.connCnt = 0;
            this.keepAlive = 0;
            this.reqFreq = 0;
            this.pkgLen = 0;
            this.finished = 0;
            this.memo = "";
            this.warmUp = 0;
            this._proto_struct_name_ = "";
            this._classname = "apitars.TestHistory";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new TestHistory;
            tmp.testID = is.readUInt32(0, true, 0);
            tmp.startTime = is.readUInt32(1, true, 0);
            tmp.endTime = is.readUInt32(2, true, 0);
            tmp.servType = is.readString(3, true, "");
            tmp.lang = is.readString(4, true, "");
            tmp.cores = is.readUInt32(5, true, 0);
            tmp.threads = is.readUInt32(6, true, 0);
            tmp.connCnt = is.readUInt32(7, true, 0);
            tmp.keepAlive = is.readUInt32(8, true, 0);
            tmp.reqFreq = is.readUInt32(9, true, 0);
            tmp.pkgLen = is.readUInt32(10, true, 0);
            tmp.finished = is.readUInt32(11, true, 0);
            tmp.memo = is.readString(12, false, "");
            tmp.warmUp = is.readUInt32(13, false, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.testID);
            os.writeUInt32(1, this.startTime);
            os.writeUInt32(2, this.endTime);
            os.writeString(3, this.servType);
            os.writeString(4, this.lang);
            os.writeUInt32(5, this.cores);
            os.writeUInt32(6, this.threads);
            os.writeUInt32(7, this.connCnt);
            os.writeUInt32(8, this.keepAlive);
            os.writeUInt32(9, this.reqFreq);
            os.writeUInt32(10, this.pkgLen);
            os.writeUInt32(11, this.finished);
            os.writeString(12, this.memo);
            os.writeUInt32(13, this.warmUp);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                testID: this.testID,
                startTime: this.startTime,
                endTime: this.endTime,
                servType: this.servType,
                lang: this.lang,
                cores: this.cores,
                threads: this.threads,
                connCnt: this.connCnt,
                keepAlive: this.keepAlive,
                reqFreq: this.reqFreq,
                pkgLen: this.pkgLen,
                finished: this.finished,
                memo: this.memo,
                warmUp: this.warmUp
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "testID") && (this.testID = json.testID);
            _hasOwnProperty.call(json, "startTime") && (this.startTime = json.startTime);
            _hasOwnProperty.call(json, "endTime") && (this.endTime = json.endTime);
            _hasOwnProperty.call(json, "servType") && (this.servType = json.servType);
            _hasOwnProperty.call(json, "lang") && (this.lang = json.lang);
            _hasOwnProperty.call(json, "cores") && (this.cores = json.cores);
            _hasOwnProperty.call(json, "threads") && (this.threads = json.threads);
            _hasOwnProperty.call(json, "connCnt") && (this.connCnt = json.connCnt);
            _hasOwnProperty.call(json, "keepAlive") && (this.keepAlive = json.keepAlive);
            _hasOwnProperty.call(json, "reqFreq") && (this.reqFreq = json.reqFreq);
            _hasOwnProperty.call(json, "pkgLen") && (this.pkgLen = json.pkgLen);
            _hasOwnProperty.call(json, "finished") && (this.finished = json.finished);
            _hasOwnProperty.call(json, "memo") && (this.memo = json.memo);
            _hasOwnProperty.call(json, "warmUp") && (this.warmUp = json.warmUp);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new TestHistory();
        }
        static create(is) {
            return apitars.TestHistory._readFrom(is);
        }
    }
    TestHistory._classname = "apitars.TestHistory";
    apitars.TestHistory = TestHistory;
    class QueryTestHistoryResp {
        constructor() {
            this.code = 0;
            this.msg = "";
            this.total = 0;
            this.page = 0;
            this.histories = new TarsStream.List(apitars.TestHistory);
            this._proto_struct_name_ = "";
            this._classname = "apitars.QueryTestHistoryResp";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new QueryTestHistoryResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            tmp.total = is.readUInt32(2, true, 0);
            tmp.page = is.readUInt32(3, true, 0);
            tmp.histories = is.readList(4, true, TarsStream.List(apitars.TestHistory));
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
            os.writeUInt32(2, this.total);
            os.writeUInt32(3, this.page);
            os.writeList(4, this.histories);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                code: this.code,
                msg: this.msg,
                total: this.total,
                page: this.page,
                histories: this.histories.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            _hasOwnProperty.call(json, "total") && (this.total = json.total);
            _hasOwnProperty.call(json, "page") && (this.page = json.page);
            _hasOwnProperty.call(json, "histories") && (this.histories.readFromObject(json.histories));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new QueryTestHistoryResp();
        }
        static create(is) {
            return apitars.QueryTestHistoryResp._readFrom(is);
        }
    }
    QueryTestHistoryResp._classname = "apitars.QueryTestHistoryResp";
    apitars.QueryTestHistoryResp = QueryTestHistoryResp;
    class IsPerfExistsReq {
        constructor() {
            this.servType = "";
            this._proto_struct_name_ = "";
            this._classname = "apitars.IsPerfExistsReq";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new IsPerfExistsReq;
            tmp.servType = is.readString(0, true, "");
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.servType);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                servType: this.servType
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "servType") && (this.servType = json.servType);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new IsPerfExistsReq();
        }
        static create(is) {
            return apitars.IsPerfExistsReq._readFrom(is);
        }
    }
    IsPerfExistsReq._classname = "apitars.IsPerfExistsReq";
    apitars.IsPerfExistsReq = IsPerfExistsReq;
    class IsPerfExistsResp {
        constructor() {
            this.code = 0;
            this.msg = "";
            this._proto_struct_name_ = "";
            this._classname = "apitars.IsPerfExistsResp";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new IsPerfExistsResp;
            tmp.code = is.readUInt32(0, true, 0);
            tmp.msg = is.readString(1, true, "");
            return tmp;
        }
        _writeTo(os) {
            os.writeUInt32(0, this.code);
            os.writeString(1, this.msg);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                code: this.code,
                msg: this.msg
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "code") && (this.code = json.code);
            _hasOwnProperty.call(json, "msg") && (this.msg = json.msg);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new IsPerfExistsResp();
        }
        static create(is) {
            return apitars.IsPerfExistsResp._readFrom(is);
        }
    }
    IsPerfExistsResp._classname = "apitars.IsPerfExistsResp";
    apitars.IsPerfExistsResp = IsPerfExistsResp;
    class apiProxy {
        setTimeout(iTimeout) { this._worker.timeout = iTimeout; }
        getTimeout() { return this._worker.timeout; }
        setVersion(iVersion) { this._worker.version = iVersion; }
        getVersion() { return this._worker.version; }
        doFuncTest(options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("doFuncTest", apiProxy.doFuncTest.tupEncoder(version), options, apiProxy.doFuncTest).then(apiProxy.doFuncTest.tupDecoder, apiProxy.doFuncTest.errorResponser);
            }
            else {
                return this._worker.tars_invoke("doFuncTest", apiProxy.doFuncTest.tarsEncoder(), options, apiProxy.doFuncTest).then(apiProxy.doFuncTest.tarsDecoder, apiProxy.doFuncTest.errorResponser);
            }
        }
        doPerfTest(req, options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("doPerfTest", apiProxy.doPerfTest.tupEncoder(req, version), options, apiProxy.doPerfTest).then(apiProxy.doPerfTest.tupDecoder, apiProxy.doPerfTest.errorResponser);
            }
            else {
                return this._worker.tars_invoke("doPerfTest", apiProxy.doPerfTest.tarsEncoder(req), options, apiProxy.doPerfTest).then(apiProxy.doPerfTest.tarsDecoder, apiProxy.doPerfTest.errorResponser);
            }
        }
        getTestDetail(testID, timestamp, showWarmUp, options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("getTestDetail", apiProxy.getTestDetail.tupEncoder(testID, timestamp, showWarmUp, version), options, apiProxy.getTestDetail).then(apiProxy.getTestDetail.tupDecoder, apiProxy.getTestDetail.errorResponser);
            }
            else {
                return this._worker.tars_invoke("getTestDetail", apiProxy.getTestDetail.tarsEncoder(testID, timestamp, showWarmUp), options, apiProxy.getTestDetail).then(apiProxy.getTestDetail.tarsDecoder, apiProxy.getTestDetail.errorResponser);
            }
        }
        getTestHistories(req, options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("getTestHistories", apiProxy.getTestHistories.tupEncoder(req, version), options, apiProxy.getTestHistories).then(apiProxy.getTestHistories.tupDecoder, apiProxy.getTestHistories.errorResponser);
            }
            else {
                return this._worker.tars_invoke("getTestHistories", apiProxy.getTestHistories.tarsEncoder(req), options, apiProxy.getTestHistories).then(apiProxy.getTestHistories.tarsDecoder, apiProxy.getTestHistories.errorResponser);
            }
        }
        isPerfExists(req, options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("isPerfExists", apiProxy.isPerfExists.tupEncoder(req, version), options, apiProxy.isPerfExists).then(apiProxy.isPerfExists.tupDecoder, apiProxy.isPerfExists.errorResponser);
            }
            else {
                return this._worker.tars_invoke("isPerfExists", apiProxy.isPerfExists.tarsEncoder(req), options, apiProxy.isPerfExists).then(apiProxy.isPerfExists.tarsDecoder, apiProxy.isPerfExists.errorResponser);
            }
        }
    }
    apiProxy.doFuncTest = _castFunctionInfo({
        name: "doFuncTest",
        return: "apitars.FuncTestResp",
        arguments: [],
        tarsEncoder() {
            const os = new TarsStream.TarsOutputStream();
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readStruct(0, true, apitars.FuncTestResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(__$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readStruct("", apitars.FuncTestResp, new apitars.FuncTestResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call api::doFuncTest failed");
        }
    });
    apiProxy.doPerfTest = _castFunctionInfo({
        name: "doPerfTest",
        return: "apitars.PerfTestResp",
        arguments: [{
                name: "req",
                class: "apitars.PerfTestReq",
                direction: "in"
            }],
        tarsEncoder(req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readStruct(0, true, apitars.PerfTestResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readStruct("", apitars.PerfTestResp, new apitars.PerfTestResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call api::doPerfTest failed");
        }
    });
    apiProxy.getTestDetail = _castFunctionInfo({
        name: "getTestDetail",
        return: "apitars.TestDetailResp",
        arguments: [{
                name: "testID",
                class: "int64",
                direction: "in"
            }, {
                name: "timestamp",
                class: "int64",
                direction: "in"
            }, {
                name: "showWarmUp",
                class: "bool",
                direction: "in"
            }],
        tarsEncoder(testID, timestamp, showWarmUp) {
            const os = new TarsStream.TarsOutputStream();
            os.writeUInt32(1, testID);
            os.writeUInt32(2, timestamp);
            os.writeBoolean(3, showWarmUp);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readStruct(0, true, apitars.TestDetailResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(testID, timestamp, showWarmUp, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeUInt32("testID", testID);
            tup.writeUInt32("timestamp", timestamp);
            tup.writeBoolean("showWarmUp", showWarmUp);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readStruct("", apitars.TestDetailResp, new apitars.TestDetailResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call api::getTestDetail failed");
        }
    });
    apiProxy.getTestHistories = _castFunctionInfo({
        name: "getTestHistories",
        return: "apitars.QueryTestHistoryResp",
        arguments: [{
                name: "req",
                class: "apitars.QueryTestHistoryReq",
                direction: "in"
            }],
        tarsEncoder(req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readStruct(0, true, apitars.QueryTestHistoryResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readStruct("", apitars.QueryTestHistoryResp, new apitars.QueryTestHistoryResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call api::getTestHistories failed");
        }
    });
    apiProxy.isPerfExists = _castFunctionInfo({
        name: "isPerfExists",
        return: "apitars.IsPerfExistsResp",
        arguments: [{
                name: "req",
                class: "apitars.IsPerfExistsReq",
                direction: "in"
            }],
        tarsEncoder(req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readStruct(0, true, apitars.IsPerfExistsResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readStruct("", apitars.IsPerfExistsResp, new apitars.IsPerfExistsResp),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call api::isPerfExists failed");
        }
    });
    apitars.apiProxy = apiProxy;
})(apitars = exports.apitars || (exports.apitars = {}));
